# 1105 vue3 源码

- mount
    - render
        - setupRenderEffect
        

## `EffectScope`

`EffectScope`  Creates an effect scope object which can capture the reactive effects

通过`EffectScope` 可以将function 以setup方式执行，形成响应式作用域 ,如：pinia defineStore

```jsx
export declare class EffectScope {
	detached: boolean;
	constructor(detached?: boolean);
	get active(): boolean;
	run<T>(fn: () => T): T | undefined;
	stop(fromParent?: boolean): void;
}

const setupStore = runWithContext(() =>
   () => (scope = effectScope()).run(setup)!
)!
```

## use

[vue.use](1105%20vue3%20%E6%BA%90%E7%A0%81%203bb4ec29478b406b9a714c07611aa31a/vue%20use%20b56fb9ea0ecf4f6a8d8470faf3a933c2.md)

## vue.component

在 vue.use 调用 plugin.install 方法，plugin.install 方法内一般包含 以下方法做全局处理

```jsx
app.component('RouterLink', RouterLink);
app.component('RouterView', RouterView);
app.directive()
app.config.globalProperties.$router = router;
app.provide(routerKey, router)

app.config.globalProperties.$pinia = pinia
```

## provide/inject

获取 `provides`，然后返回

```bash
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance || currentApp) {
    const **provides** = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
    } else if (!!(process.env.NODE_ENV !== "production")) {
      warn(`injection "${String(key)}" not found.`);
    }
  } else if (!!(process.env.NODE_ENV !== "production")) {
    warn(`inject() can only be used inside setup() or functional components.`);
  }
}

```