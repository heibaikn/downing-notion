# 1102  后缀表达式

后缀表达式（也称为逆波兰表达式）是一种用于表示数学表达式的形式，其中运算符位于操作数的后面。与常见的中缀表达式（例如：1 + 2）不同，后缀表达式不需要使用括号来明确运算符的优先级，因为运算符的顺序已经明确表示。

在后缀表达式中，运算符紧跟在操作数的后面。例如，表达式 "1 + 2" 可以用后缀表达式表示为 "1 2 +"，其中 "+" 是运算符，而 "1" 和 "2" 是操作数。

后缀表达式的一个优点是，它可以通过堆栈数据结构非常容易地进行计算。你可以从左到右遍历后缀表达式，将操作数压入堆栈，当遇到运算符时，弹出堆栈上的操作数执行相应的运算，然后将结果再次压入堆栈。这个过程重复进行，直到整个表达式被计算完毕，最后堆栈中只剩下一个结果值。

现在，让我们使用后缀表达式计算算法来计算表达式 "1 + 1 * 8 * (2 + 1)"。首先，将这个中缀表达式转换为后缀表达式：

1. 中缀表达式：1 + 1 * 8 * (2 + 1)
2. 转换为后缀表达式：1 1 8 * 2 1 + * +

然后，我们可以按照下面的步骤来计算后缀表达式：

1. 从左到右遍历后缀表达式。
2. 遇到操作数时，将其压入堆栈。
3. 遇到运算符时，从堆栈中弹出相应数量的操作数进行计算，然后将结果压回堆栈。
4. 继续重复上述步骤，直到整个表达式被计算完毕。

计算过程如下：

- 遇到 "1"，将其压入堆栈：堆栈 [1]
- 遇到 "1"，将其压入堆栈：堆栈 [1, 1]
- 遇到 "8"，将其压入堆栈：堆栈 [1, 1, 8]
- 遇到 "*" 运算符，弹出两个操作数 8 和 1，计算 8 * 1 = 8，将结果 8 压回堆栈：堆栈 [1, 8]
- 遇到 "2"，将其压入堆栈：堆栈 [1, 8, 2]
- 遇到 "1"，将其压入堆栈：堆栈 [1, 8, 2, 1]
- 遇到 "+" 运算符，弹出两个操作数 1 和 2，计算 1 + 2 = 3，将结果 3 压回堆栈：堆栈 [1, 8, 3]
- 遇到 "*" 运算符，弹出两个操作数 3 和 8，计算 3 * 8 = 24，将结果 24 压回堆栈：堆栈 [1, 24]
- 遇到 "+" 运算符，弹出两个操作数 24 和 1，计算 24 + 1 = 25，将结果 25 压回堆栈：堆栈 [25]

![Untitled](1102%20%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%2011419c71f1fa49a895a04b087340638e/Untitled.png)

最终，堆栈中只剩下一个结果值 25，这就是表达式 "1 + 1 * 8 * (2 + 1)" 的计算结果。

这是一个使用后缀表达式计算算法的示例。后缀表达式的计算不涉及括号和优先级的问题，因此可以非常直接地执行计算。

[https://github.com/heibaikn/note/blob/master/algorithm/2321calc.ts](https://github.com/heibaikn/note/blob/master/algorithm/2321calc.ts)