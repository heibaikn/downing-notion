# 1026 深拷贝

当涉及到 JavaScript 中的对象和数据拷贝时，我们通常会遇到浅拷贝和深拷贝的概念。本文将探讨这两种拷贝方法的区别、浅拷贝的应用和可能产生的问题，以及深拷贝的处理方法。

### 深拷贝和浅拷贝的区别

**浅拷贝**只复制了对象的第一层结构，而没有复制嵌套对象或数组内部的元素。浅拷贝通常使用 `Object.assign`、展开运算符 `...` 或 `Array.slice()` 等方法来实现。浅拷贝会导致拷贝对象与原始对象共享引用，因此对拷贝对象的修改可能会影响原始对象。

**深拷贝**则完全复制了对象及其嵌套结构，包括所有子对象和数组。深拷贝可以防止原始对象和拷贝对象之间的引用共享，确保它们是独立的。

### 浅拷贝的应用和问题

### 应用

浅拷贝在一些场景下非常有用，例如：

- 快速复制对象的第一层结构，以便在不影响原始对象的情况下进行修改。
- 将对象的属性合并到另一个对象中，通常使用 `Object.assign` 或展开运算符 `...`。
- 利用 共享引用特性，实现数据的修改

### 问题

浅拷贝可能导致一些问题：

- **共享引用**：拷贝对象与原始对象之间共享引用，修改其中一个对象可能会影响另一个对象。
- **不处理嵌套对象**：浅拷贝不会递归处理嵌套对象或数组，导致嵌套结构的数据不被拷贝。

### 深拷贝处理

深拷贝通常需要特殊处理，以确保所有嵌套结构都得到正确的复制。以下是深拷贝的处理方法：

1. **标准 JSON 的处理**：使用 `JSON.parse(JSON.stringify(obj))` 可以实现深拷贝，但它有一些限制，例如不能处理特殊类型（如函数、BigInt）以及循环引用。
    
    ```jsx
    JSON.stringify(sourceObject)
    
    ```
    
2. **处理函数和 BigInt**：对于函数和 BigInt。这通常涉及检测对象的类型并进行相应的处理。
    
    ```jsx
    function deepClone(obj) {
      if (typeof obj !== 'object' || obj === null) {
        return obj;
      }
      let newObj = Array.isArray(obj) ? [...obj] : { ...obj };
      Reflect.ownKeys(obj).forEach(key => {
        newObj[key] = deepClone(obj[key], cache);
      });
      return newObj;
    }
    ```
    
3. **嵌套引用的处理**：要处理嵌套引用，你可以使用一个缓存对象（如 `WeakMap` `weakSet`）来跟踪已经处理过的对象，以防止循环引用和重复拷贝
    
    ```jsx
    function deepClone(obj, **cache = new WeakSet()**) {
      if (typeof obj !== 'object' || obj === null) {
        return obj;
      }
      if (cache.has(obj)) {
        return obj;
      }
      let newObj = Array.isArray(obj) ? [...obj] : { ...obj };
      cache.add(obj);  
      Reflect.ownKeys(obj).forEach(key => {
        newObj[key] = deepClone(obj[key], cache);
      });
      return newObj;
    }
    ```
    
4. **处理不可枚举属性**：使用 `Object.getOwnPropertyNames` 来获取对象的不可枚举属性，确保它们也被正确复制
    
    ```jsx
    
    function deepClone(obj, cache = new WeakSet()) {
      if (typeof obj !== 'object' || obj === null) {
        return obj;
      }
      if (cache.has(obj)) {
        return obj;
      }
      let newObj 
      if (Array.isArray(obj)) {
        newObj = [...obj];
      } else if (obj.constructor) {
        newObj = new obj.constructor();
      } else {
        newObj = Object.create(null);
      }
      cache.add(obj);
      **const propNames = Object.getOwnPropertyNames(obj);**
    
      for (const key of propNames) {
        const descriptor = Object.getOwnPropertyDescriptor(obj, key);
        if (descriptor.enumerable) {
          newObj[key] = deepClone(obj[key], cache);
        } else {
          Object.defineProperty(newObj, key, descriptor);
        }
      }
      return newObj;
    }
    
    const sourceObject = {
      name: 'John',
      address: {
        city: 'New York',
        zip: '10001'
      },
      friend: {
        name: 'Alice',
        address: 1
      },
      array: [1, 2, 3, { a: 1 }],
      func: () => { },
      pointer: {}
    };
    Object.defineProperty(sourceObject, 'secret', {
      value: 'sensitive data',
      enumerable: false
    });
    sourceObject.pointer = sourceObject
    const targetObject = deepClone(sourceObject)
    
    targetObject.address.city = 'sh'
    console.log(targetObject);
    console.log(targetObject.address.city === sourceObject.address.city);
    ```
    
5. **处理 Set 和 Map**：对于 `Set` 和 `Map`，你需要判断类型，然后手动迭代元素，并递归深拷贝值
    
    ```jsx
    function deepClone(obj, cache = new WeakSet()) {
      if (typeof obj !== 'object' || obj === null) {
        return obj;
      }
      if (cache.has(obj)) {
        return obj;
      }
      let newObj
      if (Array.isArray(obj)) {
        newObj = [...obj];
      } else if (**obj.constructor === Set**) {
        newObj = new Set();
        obj.forEach(value => {
          newObj.add(deepClone(value));
        });
        return newObj
      } else if (**obj.constructor === Map**) {
        newObj = new Map();
        obj.forEach((value, key) => {
          newObj.set(key, deepClone(value));
        });
        return newObj
      } else if (obj.constructor) {
        newObj = new obj.constructor();
      } else {
        newObj = Object.create(null);
      }
      cache.add(obj);
      const propNames = Object.getOwnPropertyNames(obj);
    
      for (const key of propNames) {
        const descriptor = Object.getOwnPropertyDescriptor(obj, key);
        if (descriptor.enumerable) {
          newObj[key] = deepClone(obj[key], cache);
        } else {
          Object.defineProperty(newObj, key, descriptor);
        }
      }
      return newObj;
    }
    
    const sourceObject = {
      name: 'John',
      set: new Set([1, 2, 3]),
      map: new Map([[1, 1], [2, 2]]),
      obj: {
        city: 'New York',
        zip: '10001'
      },
      array: [1, 2, 3, { a: 1 }],
      func: () => { },
      pointer: {}
    };
    Object.defineProperty(sourceObject, 'secret', {
      value: 'sensitive data',
      enumerable: false
    });
    sourceObject.pointer = sourceObject
    const targetObject = deepClone(sourceObject)
    
    targetObject.obj.city = 'sh'
    targetObject.set.add(1)
    console.log(targetObject,sourceObject);
    console.log(targetObject.obj.city === sourceObject.obj.city);
    console.log(targetObject.set.size === sourceObject.set.size);
    ```
    

综合以上方法，你可以实现一个健壮的深拷贝函数，可以处理各种类型的对象，包括函数、BigInt、嵌套引用、不可枚举属性、Set 和 Map。

深拷贝在处理复杂对象和数据结构时非常有用，它确保你得到了独立的副本，不会影响原始数据。但要注意，深拷贝可能会消耗更多的计算资源，因此在性能要求较高的情况下要小心使用。