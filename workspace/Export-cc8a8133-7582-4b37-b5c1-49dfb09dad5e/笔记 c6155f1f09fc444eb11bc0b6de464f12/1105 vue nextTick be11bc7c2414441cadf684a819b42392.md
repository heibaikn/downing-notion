# 1105 vue nextTick

1. Vue使用了dom异步更新机制，也叫"批处理”，和单线程同步处理不一样，更新是由`updateComponent` `effect.run()`  执行

特性1：异步更新，是通过 scheduler 中 的promise.then 执行`() => queueJob(()=>effect.run())`

特性2：批处理有2个逻辑实现，一是vm.update() 会缓存单个组件内的 所有m的变化， 二是 scheduler中会缓存 单个宏任务中的所有组件的update()

- 逻辑 ，当前宏任务的 dom变化会 存储在 `scheduler`的queue里，const currentFlushPromise= promise.then 中执行 `effect.run()` , 然后在 currentFlushPromise.then 中执行 nextTick的回调
    - promise2 的then链会被放入微任务队列，并返回一个promise

**在effect里面传入第二个参数，scheduler函数里面需要维护一个队列，方便保存当前的effect的run函数，然后把run函数放入微任务中进行执行就ok了**。

当然，在放入微任务之前，维护的队列中需要判断runner是否重复，重复只添加一次，然后取除队列中的第一项放入微队列中执行

```jsx
// effect
export class ReactiveEffect<T = any> {
  // ....
  constructor(
    public fn: () => T,
    public scheduler: EffectScheduler | null = null,
    scope?: EffectScope
  ) {
    recordEffectScope(this, scope)
  }

  run() {
	  // ...
  }

  stop() {
 
  }
}

// mvvm 中 触发m 改变v
function triggerEffect(
  effect: ReactiveEffect,
  debuggerEventExtraInfo?: DebuggerEventExtraInfo
) {
  if (effect !== activeEffect || effect.allowRecurse) {
  
    if (effect.scheduler) {
      effect.scheduler()
    } else {
      effect.run()
    }
  }
}
```

```jsx
// render.ts
const setupRenderEffect: SetupRenderEffectFn = (
    instance,
    initialVNode,
    container,
    anchor,
    parentSuspense,
    isSVG,
    optimized
  ) => {
		//...
		//...
		// create reactive effect for rendering
		const effect = (instance.effect = new ReactiveEffect(
		  componentUpdateFn,
		  () => queueJob(update),
		  instance.scope // track it in component's effect scope
		))
		
		const update: SchedulerJob = (instance.update = () => effect.run())
		update.id = instance.uid
		// allowRecurse
		// #1801, #2043 component render effects should allow recursive updates
		toggleRecurse(instance, true)
		update()
}

```

`queueJob` 是 SchedulerJob 的队列

```jsx
//scheduler.ts

const queue: SchedulerJob[] = []
// currentFlushPromise || resolvedPromis dom更新标识
// 若有 cb 执行 p.then(this ? fn.bind(this) : fn)
export function nextTick<T = void, R = void>(
  this: T,
  fn?: (this: T) => R
): Promise<Awaited<R>> {
  const p = currentFlushPromise || resolvedPromise
  return fn ? p.then(this ? fn.bind(this) : fn) : p
}

export function queueJob(job: SchedulerJob) {
  // the dedupe search uses the startIndex argument of Array.includes()
  // by default the search index includes the current job that is being run
  // so it cannot recursively trigger itself again.
  // if the job is a watch() callback, the search will start with a +1 index to
  // allow it recursively trigger itself - it is the user's responsibility to
  // ensure it doesn't end up in an infinite loop.
  if (
    !queue.length ||
    !queue.includes(
      job,
      isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
    )
  ) {
    if (job.id == null) {
      queue.push(job)
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job)
    }
    queueFlush()
  }
}

function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true
    currentFlushPromise = resolvedPromise.then(flushJobs)
  }
}
// 更新dom
function flushJobs(seen?: CountMap) {
  isFlushPending = false
  isFlushing = true
 

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child so its render effect will have smaller
  //    priority number)
  // 2. If a component is unmounted during a parent component's update,
  //    its update can be skipped.
  queue.sort(comparator)

  // conditional usage of checkRecursiveUpdate must be determined out of
  // try ... catch block since Rollup by default de-optimizes treeshaking
  // inside try-catch. This can leave all warning code unshaked. Although
  // they would get eventually shaken by a minifier like terser, some minifiers
  // would fail to do that (e.g. https://github.com/evanw/esbuild/issues/1610)
  const check = __DEV__
    ? (job: SchedulerJob) => checkRecursiveUpdates(seen!, job)
    : NOOP

  try {
    debugger
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex]
      if (job && job.active !== false) {
        if (__DEV__ && check(job)) {
          continue
        }
        // console.log(`running:`, job.id)
        callWithErrorHandling(job, null, ErrorCodes.SCHEDULER)
      }
    }
  } finally {
    flushIndex = 0
    queue.length = 0

    flushPostFlushCbs(seen)

    isFlushing = false
    currentFlushPromise = null
    // some postFlushCb queued jobs!
    // keep flushing until it drains.
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs(seen)
    }
  }
}
```